using UnityEngine;

public class MovePlayer : MonoBehaviour
{

    public float speed = 5f, hSpeed = 10f , _thrust = 500f;

    private Rigidbody _rb;

    private void Awake()  // сразу в начале игры получаем компонент, чтомы в других методах не обращаться к поиску
    {
        _rb = GetComponent<Rigidbody>();
    }

    private void FixedUpdate() { // метод FixedUpdate больше подходит для работы с физикой так как вызывается через
                                 // равные промежутки времени, поэтому используем его вместо Update

        float h = Input.GetAxis("Horizontal") * hSpeed * Time.fixedDeltaTime; // в переменные кладем нажатия от пользователя на стрелки
                                                                              //обращаемся к классу Input методу GetAxis и  указываем плоскость
                                                                              // которую отслеживаем "Horizontal" и сразу умножаем на скорость и время 
        float v = Input.GetAxis("Vertical") * speed * Time.fixedDeltaTime;

        _rb.velocity = transform.TransformDirection(new Vector3(v, _rb.velocity.y, -h)); //velocity- это как будто скорость для объекта, его позиция и мы их меняем. Чтобы
                                                                                         //выполнить передвижение обращаемся к компоненту transform и к методу TransformDirection
                                                                                         //с помощью которого мы можем корректно указывать по каким координатам будем передвигать 
                                                                                         // объект, после уже к классу Vector3 куда подставляем переменные. По Y никак не передвигаю  
                                                                                         // объект и лучше не устанавливать 0 т.к.если будет какая-то ямка то объект не будет падать,
                                                                                         // поэтому обращаемся так _rb.velocity.y и будем отслеживать новый координат, и объект у нас будет
                                                                                         // корректно падать.


    }
    private void OnCollisionEnter(Collision other) { // OnCollisionEnter - метод который срабатывает каждый раз при соприкосновении объектов(условие: должно быть оба твердых объекта один 
                                                     // с физикой, и на основном игроке должен быть компонент Collider и RigidBody)
        if (other.gameObject.name == "Block")        // Чтобы реализовать отслеживание соприкосновения не все а только с определенным объектом при соприкосновении с которым будем выполнять
                                                     // определенный код то прописываем условие и обращаемся к параметру other(это по сути игровой объект с которым мы соприкоснулись) - поэтому
                                                     // мы можем взять у него все имя, компоненты, удалить и т.д. Поэтому мы проверяем название: обращаемся к other потом к gameObject - чтобы 
                                                     // взять этот объект как игровой и сравниваем имя со стрингой. Каждый раз при новом соприкосновении этот метод будет срабатывать.
        {
            _rb.AddForce(new Vector3(0, 1, 0) * _thrust); // чтобы отбрасывало объект: обращаемся к _rb компоненту, к специальному методу AddForce() который дает силу толчка и после указываем
                                                         // по какой координате даем силу толчка, и все умножаем на значение силы толчка.
        }
    }
    private void OnCollisionStay(Collision other)    // Метод который вызывается все время пока мы соприкосаемся с каким-либо твердым объектом 
    {    
    }
    private void OnCollisionExit(Collision other)   // Метод который срабатывает в момент когда наоборот перестаем соприкасаться с каким-либо объектом
    {      
    }
    private void OnTriggerEnter(Collider other)  // сработает как только соприкоснемся с тригером(в пустотелым объектом)
    {
        if(other.gameObject.name == "TriggerMain")
        {
            Debug.Log("Triger Correct");
        }
    }
    private void OnTriggerExit(Collider other) // сработает один раз когда мы уже не соприкосаемся с тригером(в пустотелым объектом)
    {
        if (other.gameObject.name == "TriggerMain")
        {
            Destroy(gameObject);       // удаляем сам игровой объект
        }
    }
    private void OnTriggerStay(Collider other) // сработает все время пока соприкосаемся с тригером(в пустотелым объектом)
    {
        if (other.gameObject.name == "TriggerMain")
        {
            Debug.Log("Triger stay");
        }
    }


}

// private void Update()
//{
//if(Input.GetKey(KeyCode.UpArrow) || Input.GetKey(KeyCode.W)) //отслеживаем нажатие на стрелку вверх и W; GetKeyUp -срабатывает один раз в момент нажатия
//GetKey - когда зажимаем клавишу то условие всегда будет срабатывать как верное
//transform.Translate(new Vector3(1,0,0) * Time.deltaTime * speed);   //обратиться к компоненту можно через метод GetComponent, но здесь он не понадобится
//т.к. сам скрипт находится на объекте к которому мы должны обратиться к компоненту 
//Transform, то можно не обращаться к методу GetComponent а сразу прописать transform
//и обращаетмя к методу Translate() и таким образом мы обратились к нужному компоненту transform
//указываем по каким координатам бумем передвигать объект new Vector3(1,0,0), * Time.deltaTime
// - чтобы выполнялось плавно и умножаем на скорость которую кладем в переменную

//gameObject.SetActive(false); //если нужно обратиться не просто к компоненту transform а ко всему игровому объекту
//то существует еще одно ключевое слово gameObject, таким образом обращаемся ко всему игровому объекту 
// где у нас находится script. И уже тем самым могли вызвать метод SetActive указав значение false,
// спрятав игровой объект.

//if (Input.GetKey(KeyCode.DownArrow) || Input.GetKey(KeyCode.S)) //отслеживаем нажатие на стрелку вверх и W
//    transform.Translate(new Vector3(1, 0, 0) * Time.deltaTime * -speed);

// float v = Input.GetAxis("Vertical");  // Еще один способ как можно передвигать сам по себе объект: в переменную кладем: обращаемся к классу Imput после
// к специальному методу GetAxis где указываем название нужного отслеживания "Vertical". В Unity существуют сразу
// установленные отслеживания и такое как 'Vertical'- отслеживает нажатие на вверх - вниз и W - S.
//  Если к примеру нажимаем на W то в переменную помещается значение от -1 -если вниз,1-вверх, 0-нет нажатия.
//  Удобно тем что можем передвигать объект по той же самой координате, только не дописываем условия а умножаем на
//  переменную. И таким образом если мы умножаем на 0 то объект не двигается 
//transform.Translate(new Vector3(1, 0, 0) * Time.deltaTime * speed * v); 

//float h = Input.GetAxis("Horizontal"); // то же самое по горизонтали
// transform.Translate(new Vector3(0, 0, -1) * Time.deltaTime * speed * h); 
// }
